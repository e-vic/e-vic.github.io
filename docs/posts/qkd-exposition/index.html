<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Emma Hansen">
<meta name="dcterms.date" content="2024-02-29">

<title>Notes - A Brief Exposition on Quantum Key Rate Calculations and Optimisation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="../../site_libs/quarto-contrib/glightbox/glightbox.min.js"></script>
<link href="../../site_libs/quarto-contrib/glightbox/glightbox.min.css" rel="stylesheet">
<link href="../../site_libs/quarto-contrib/glightbox/lightbox.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script async="" src="https://hypothes.is/embed.js"></script>
<script>
  window.document.addEventListener("DOMContentLoaded", function (_event) {
    document.body.classList.add('hypothesis-enabled');
  });
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="floating nav-fixed slimcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Contents</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default toc-left page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">A Brief Exposition on Quantum Key Rate Calculations and Optimisation</h1>
                      </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-heading">Affiliation</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author">Emma Hansen </p>
    </div>
    <div class="quarto-title-meta-contents">
          <p class="affiliation">
              University of British Columbia Department of Mathematics
            </p>
        </div>
    </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">February 29, 2024</p>
      </div>
    </div>
    
      
    </div>
    
  <div>
    <div class="abstract">
      <div class="block-title">Abstract</div>
      <p>This exerpt, from the report I wrote for my candidacy exam, contains a brief description of quantum key distribution key rate calculations, and outlines one approach to solving for the key rate as a minimisation problem.</p>
    </div>
  </div>
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#quantum-key-distribution" id="toc-quantum-key-distribution" class="nav-link active" data-scroll-target="#quantum-key-distribution"><span class="header-section-number">1</span> Quantum Key Distribution</a>
  <ul class="collapse">
  <li><a href="#notation" id="toc-notation" class="nav-link" data-scroll-target="#notation"><span class="header-section-number">1.1</span> Notation</a></li>
  </ul></li>
  <li><a href="#formulating-the-key-rate-calculation" id="toc-formulating-the-key-rate-calculation" class="nav-link" data-scroll-target="#formulating-the-key-rate-calculation"><span class="header-section-number">2</span> Formulating the key rate calculation</a>
  <ul class="collapse">
  <li><a href="#a-solution-approach-by-winick-et-al." id="toc-a-solution-approach-by-winick-et-al." class="nav-link" data-scroll-target="#a-solution-approach-by-winick-et-al."><span class="header-section-number">2.1</span> A solution approach by Winick et al.</a></li>
  <li><a href="#sec-bb84ex" id="toc-sec-bb84ex" class="nav-link" data-scroll-target="#sec-bb84ex"><span class="header-section-number">2.2</span> Example: BB84 protocol</a></li>
  </ul></li>
  </ul>
</nav>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<p><span class="math display">\[
\renewcommand{\H}{\mathcal{H}}
\newcommand{\tr}{\textnormal{tr}\,}
\newcommand{\A}{\mathcal{A}}
\newcommand{\Ac}{\mathcal{A}^*}
\newcommand{\N}{\mathcal{N}}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\Z}{\mathcal{Z}}
\newcommand{\G}{\mathcal{G}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\st}{\hspace{0.7mm}\textnormal{s.t.}\hspace{0.7mm}}
\DeclareMathOperator*{\argmax}{arg\,max}
\DeclareMathOperator*{\argmin}{arg\,min}
\newcommand{\&lt;}{\langle}
\renewcommand{\&gt;}{\rangle}
\newcommand{\diag}{\textnormal{\textbf{diag}}}
\newcommand{\eigs}{\textnormal{\textbf{eigs}}}
\newcommand{\Diag}{\textnormal{\textbf{Diag}}}
\newcommand{\T}{^\textsf{T}}
\newcommand{\B}{\mathcal{B}}
\newcommand{\Bc}{\mathcal{B}^*}
\newcommand{\one}{\mathbf{1}}
\renewcommand{\phi}{\varphi}
\]</span></p>
<section id="quantum-key-distribution" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Quantum Key Distribution</h1>
<p>To begin talking about quantum key rates, we must first talk about quantum cryptography and quantum encryption schemes. By now, most people have probably heard at some point “quantum computers are going to be able to hack secure information in a fraction of the time of classical computers", or”RSA encryption will be useless against quantum computers", or something of the like. And, although it will be a while before quantum computers are powerful enough to pose a real threat to current encryption schemes, it’s important to get ahead of the development and have quantum-safe encryption schemes ready to implement. Quantum key distribution (QKD) is just one of the many disciplines that provide a solution to the threat quantum computers pose to classical encryption <span class="citation" data-cites="Broadbent_Schaffner_2016">(<a href="#ref-Broadbent_Schaffner_2016" role="doc-biblioref">Broadbent and Schaffner 2016</a>)</span>.</p>
<p>As in classical encryption, quantum encryption schemes use an encryption <em>key</em> to distort information so that eavesdropper can’t infer anything useful, and then use another key held by a trusted correspondent to decrypt the information. The discipline of quantum key distribution encompasses the creation of key distribution protocols, and the calculation of key rates for these protocols. QKD protocols are the processes used to create and distribute the keys between sender and receiver. To fully define a QKD protocol, you need to define the state of the qubits that Alice can prepare, methods Alice and Bob will use to measure the qubits, a potential third party Charlie to convey information to Alice and Bob, and the method through which Alice and Bob exchange information about their measurements <span class="citation" data-cites="Winick_Lütkenhaus_Coles_2018">(<a href="#ref-Winick_Lütkenhaus_Coles_2018" role="doc-biblioref">Winick, Lütkenhaus, and Coles 2018</a>)</span>. To analyse a protocol, you need to define a model for environment noise, and an attack method for Eve to use - these determine the quantum channel.</p>
<p>To build a concrete understanding of what a QKD protocol encompasses, we will go through a simple protocol as an example, the BB84 protocol (named after its inventors Charles Bennett and Gilles Brassard <span class="citation" data-cites="Bennett_Brassard_2014">(<a href="#ref-Bennett_Brassard_2014" role="doc-biblioref">Bennett and Brassard 2014</a>)</span>). This description for this example is restated from Nielsen and Chuang <em>Quantum Computation and Quantum Information</em> <span class="citation" data-cites="Nielsen_Chuang_2012">(<a href="#ref-Nielsen_Chuang_2012" role="doc-biblioref">Nielsen and Chuang 2012</a>)</span>.</p>
<div id="nte-bb84" class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note&nbsp;1: BB84
</div>
</div>
<div class="callout-body-container callout-body">
<p>Alice starts with two strings, <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, of <span class="math inline">\((4+\delta)n\)</span> random classical bits (this is a very specific number, the reasoning behind it coming from the security proof). She then encodes the classical bits from string <span class="math inline">\(a\)</span> in qubits by choosing one of two spin bases (spin up/down - <span class="math inline">\(X\)</span>, and spin diagonal - <span class="math inline">\(Z\)</span>) determined by string <span class="math inline">\(b\)</span>. This means each qubit is one of the following states</p>
<p><span class="math display">\[\begin{aligned}
    &amp;\ket{\phi_{00}} = \ket{0} = \left[\begin{array}{c}
         1 \\
         0
    \end{array}\right], \
    \ket{\phi_{01}} = \ket{1} = \left[\begin{array}{c}
         0 \\
         1
    \end{array}\right], \\
    &amp;\ket{\phi_{10}} = \ket{+} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1}), \
    \ket{\phi_{11}} = \ket{-} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1}).
\end{aligned}\]</span></p>
<p>The labelling of the individual states indicates the value from string <span class="math inline">\(a\)</span> first, and the basis chosen as from string <span class="math inline">\(b\)</span> second, <span class="math inline">\(\ket{\phi_{a_k b_k}}\)</span>. The complete state of Alice’s system is given by the superposition of the states of the individual qubits, written as</p>
<p><span class="math display">\[\begin{aligned}
    \ket{\phi} = \bigotimes_{k=1}^{(4+\delta)n} \ket{\phi_{a_k b_k}},
\end{aligned}\]</span></p>
<p>which is the notation for the tensor product of the individual state vectors.</p>
<p>Alice now sends <span class="math inline">\(\ket{\phi}\bra{\phi}\)</span> to Bob, which is the density matrix form of the state. Bob receives it in the form <span class="math inline">\(\mathcal{E}(\ket{\phi}\bra{\phi})\)</span>, where <span class="math inline">\(\mathcal{E}\)</span> is the linear map describing the changes due to noise and interference by Eve. Bob then announces publicly that he has received the state, and measures in a randomly selected string of bases (either the <span class="math inline">\(X\)</span> or <span class="math inline">\(Z\)</span> basis) determined by his string <span class="math inline">\(b'\)</span>, and stores the values in a string <span class="math inline">\(a'\)</span>. In between all of this Eve has measured and re-sent qubits in her own randomly selected string of bases, if she guessed the wrong basis then the state will have been disturbed.</p>
<p>Alice now announces publicly what her basis string <span class="math inline">\(b\)</span> contained, and Alice and Bob both discard the elements of their strings <span class="math inline">\(a\)</span> and <span class="math inline">\(a'\)</span> for which Bob chose the wrong measurement basis (this is a type of <em>sifting</em> procedure). Assuming this leaves <span class="math inline">\(2n\)</span> bits remaining, Alice will now select <span class="math inline">\(n\)</span> of her remaining bits and announce the indices to Bob so they can publicly compare values and check for noise and interference. If more than <span class="math inline">\(t\)</span> bits differ, then they abort and re-try. The value <span class="math inline">\(t\)</span> is chosen so that they can then apply information reconciliation and privacy amplification to the remaining bits.</p>
</div>
</div>
<p>The BB84 protocol is a type of “prepare and measure" protocol, another popular type of protocol is entanglement-based, where Charlie prepares an bipartite entangled state and sends one part to Alice and one to Bob. For this report we will focus on prepare and measure protocols.</p>
<p>We now move on to the second part of QKD: the computation of key rates for distribution protocols. The key rate is what quantifies how much usable secret key is distributed by a given protocol, it is the number of established secret key bits divided by the number of distributed quantum systems (number of qubits) <span class="citation" data-cites="Coles_Metodiev_Lütkenhaus_2016">(<a href="#ref-Coles_Metodiev_Lütkenhaus_2016" role="doc-biblioref">Coles, Metodiev, and Lütkenhaus 2016</a>)</span>. Protocols with higher key rates are more desirable, so the ability to calculate a key rate for a distribution protocol is an important step in the development of new distribution protocols. Unfortunately (for quantum cryptographers, fortunately for me!) calculating the key rate is a pretty difficult problem. <span class="citation" data-cites="Devetak_Winter_2005">Devetak and Winter (<a href="#ref-Devetak_Winter_2005" role="doc-biblioref">2005</a>)</span> developed a formula for the key rate given known states of Alice, Bob, and Eve, but computing the key rate with those parameters specified only gives part of the picture. In order to be sure the protocol will work under all circumstances (all possible joint states of Alice, Bob, and Eve), a worst case key rate is computed. This is an optimisation problem whose solution lower bounds all possible key rates for a given protocol.</p>
<p>The rest of this section contains descriptions of some of the quantum information theory concepts discussed, which will hopefully provide some foundation for your thoughts. It concludes with some notation.</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
A crash course in quantum states
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The state of a qubit is represented by a length two vector written in bra-ket form, <span class="math inline">\(\ket{v}\)</span> - a “ket”. For a general qubit, this is a superposition (linear combination) of the computational basis vectors</p>
<p><span class="math display">\[\ket{0} = \left[ \begin{array}{c}
1\\
0 \end{array} \right], \ \ \ket{1} = \left[ \begin{array}{c}
0\\
1 \end{array} \right].\]</span></p>
<p>A single qubit state could look like <span class="math inline">\(\ket{v} = \frac{1}{\sqrt{2}} \ket{0} + \frac{1}{\sqrt{2}} \ket{1}\)</span>. The coefficients of the states must satisfy <span class="math inline">\(||\ket{v}|| = 1\)</span>, the squares of the coefficients are the probability that <span class="math inline">\(\ket{v}\)</span> is in the associated state.</p>
<p>The state of a collection of qubits is called a quantum system or <em>register</em>, and is represented by the tensor product of the states of all the qubits in the system. For a system of <span class="math inline">\(m\)</span> qubits, this is <span class="math inline">\(\ket{\phi} = \bigotimes_{i=1}^m \ket{a_i}\)</span>. If we take <span class="math inline">\(m=2\)</span>, the computational basis is now</p>
<p><span class="math display">\[\ket{00} = \left[ \begin{array}{c}
1\\ 0 \\0\\0\end{array} \right],
\ \ \ket{01} = \left[ \begin{array}{c}
0\\ 1 \\0\\0\end{array} \right],
\ \ \ket{10} = \left[ \begin{array}{c}
0\\0 \\1\\0\end{array} \right],
\ \ \ket{11} = \left[ \begin{array}{c}
0\\0\\0\\1\end{array} \right],\]</span></p>
<p>representing the possible combinations of the states of each qubit.</p>
<p>The state of a quantum system is frequently represented by a density matrix, this is an <span class="math inline">\(m\times m\)</span> Hermitian matrix. To relate this to the representation of a state as a vector, we need to build a distinction between pure quantum states and mixed quantum states.</p>
<p>A pure state is one whose density matrix can be written as an outer product of a single ket</p>
<p><span class="math display">\[\rho = \ket{\phi}\bra{\phi}.\]</span></p>
<p>Density matrices of pure states are rank 1. A mixed state is one whose density matrix cannot be written as a single outer product</p>
<p><span class="math display">\[\rho = \sum_{i=1}^n a_i \ket{\phi_i}\bra{\phi_i}. \]</span></p>
<p>The coefficients <span class="math inline">\(a_i\)</span> denote the probability with which the system is in state <span class="math inline">\(\ket{\phi_i}\)</span>, and since the <span class="math inline">\(\ket{\phi_i}\)</span> are unit vectors the <span class="math inline">\(a_i\)</span> are the eigenvalues of <span class="math inline">\(\rho\)</span>. For example, <span class="math inline">\(\rho =  \ket{00}\bra{00}\)</span> is a pure state, and <span class="math inline">\(\sigma = \frac{1}{\sqrt{2}} \ket{00}\bra{00} + \frac{1}{\sqrt{2}} \ket{01}\bra{01}\)</span> is a mixed state.</p>
<p>Focussing now on pure states, let’s say we have two registers, A and B, and denote states from these registers as <span class="math inline">\(\ket{\phi}_A\)</span> and <span class="math inline">\(\ket{\phi}_B\)</span> respectively. The joint state of A and B, call this AB, can be either separable or entangled. If the joint state is separable, it can be factored as</p>
<p><span class="math display">\[\ket{\phi}_{AB} = \left(\sum_{i=1}^k \alpha_i\ket{\phi_i}_A + \beta_i\ket{\phi_i})_B \right)\otimes\left(\sum_{i=1}^k \alpha_i\ket{\phi_i}_A + \beta_i\ket{\phi_i})_B \right).\]</span></p>
<p>Note that a common shorthand for the tensor product of kets is <span class="math inline">\(\ket{a}\otimes\ket{b} = \ket{a}\ket{b} = \ket{ab}\)</span>. If the joint state is entangled, then it can’t be factored like that. For example, <span class="math inline">\(\ket{\phi}_{AB} = \frac{1}{\sqrt{2}} (\ket{0_A 0_B} + \ket{1_A 1_B})\)</span> is an entangled state and <span class="math inline">\(\ket{\psi}_{AB} = \frac{1}{2}(\ket{0_A 0_B} + \ket{0_A 1_B} + \ket{1_A 0_B} + \ket{1_A 1_B})\)</span> is a separable state because it can be factored: <span class="math inline">\(\ket{\psi}_{AB} = \frac{1}{2}(\ket{0}_A + \ket{1}_A)(\ket{0}_B + \ket{1}_B)\)</span>.</p>
<p>Information in this note was collected from Joe Salfi’s Introduction to Quantum Information and Computing course and Wikipedia (<span class="citation" data-cites="Salfi-course_2023">Salfi (<a href="#ref-Salfi-course_2023" role="doc-biblioref">2023</a>)</span>,<span class="citation" data-cites="Qubit_2024"><span>“Qubit”</span> (<a href="#ref-Qubit_2024" role="doc-biblioref">2024</a>)</span>,<span class="citation" data-cites="Quantum-entanglement_2024"><span>“Quantum Entanglement”</span> (<a href="#ref-Quantum-entanglement_2024" role="doc-biblioref">2024</a>)</span>).</p>
</div>
</div>
</div>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Measuring quantum systems
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Measurement of quantum systems is characterized by projection operators. A projection operator is correlated with a measurement outcome, and the result of the measurement is the probability of obtaining said measurement outcome. Let’s say we have a projection operator <span class="math inline">\(P = \ket{00}\bra{00}\)</span> corresponding to measurement outcome that both qubits are 0, then if we apply this to a state <span class="math inline">\(\rho = \frac{1}{4} \ket{00}\bra{00} + \frac{3}{4} \ket{10}\bra{10}\)</span>, the result is <span class="math inline">\(\frac{1}{4}\)</span>. Measurements can also be generalised to something called a positive operator-valued measure (POVM). A POVM is defined as a collection of positive semi-definite matrices <span class="math inline">\(\{P_i\}\)</span> that sum to the identity</p>
<p><span class="math display">\[\sum_{i=1}^k P_i = I.\]</span></p>
<p>Each POVM element <span class="math inline">\(P_i\)</span> corresponds to a measurement outcome indexed by <span class="math inline">\(i\)</span>, and the result of the measurement gives the probability of obtaining outcome <span class="math inline">\(i\)</span></p>
<p><span class="math display">\[\text{Prob}(i) = \tr(\rho P_i).\]</span></p>
<p>Projection measurements can be used to determine the density matrix of an unknown quantum system <span class="math inline">\(\sigma\)</span>. You can define the set of measurement operators to correspond to all possible states <span class="math inline">\(\{\ket{\phi_i}\}_{i=1}^n\)</span> the system could exist in, then the outcome of the measurement is the probability <span class="math inline">\(p_i\)</span> that the system is in state <span class="math inline">\(\ket{\phi_i}\)</span>. Let <span class="math inline">\(\sigma'\)</span> denote the reconstructed system, it is defined as</p>
<p><span class="math inline">\(\sigma' = \sum_{i=1}^n p_i \ket{\phi_i}\bra{\phi_i}.\)</span>$</p>
<p>To provide the brain with something to hold onto while talking about “measuring” qubits, we describe, at a very high level, one method of doing so: spin selective tunnelling.</p>
<p>While it is possible to measure the spin of a quantum particle, it is time consuming - but most encryption protocols use spin qubits, meaning fast and reliable measurement is necessary. Spin selective tunnelling is a method to determine particle spin by measuring a charge (which is much faster to do). Suppose you have a qubit of known spin in a two state reservoir (remembering from chemistry that particles like electrons can have different activation states), next to this reservoir you have a different one state reservoir with a qubit of unknown spin. Quantum chemistry dictates that it is much harder for a particle with the same direction spin to tunnel to the left, but particles with opposite spin can tunnel much easier. When a particle tunnels and changes state, a small charge is emitted, and this is what is measured. Whether or not a charge is detected will determine if the measurement is taken to be a 0 or a 1 (based on the spin of the known qubit).</p>
<div class="wrapfigure">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="spinselect.jpg" class="lightbox" data-gallery="quarto-lightbox-gallery-1"><img src="spinselect.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:30.0%"></a></p>
</figure>
</div>
</div>
<p>Information in this note was collected from Joe Salfi’s Introduction to Quantum Information and Computing course and Wikipedia (<span class="citation" data-cites="Salfi-course_2023">Salfi (<a href="#ref-Salfi-course_2023" role="doc-biblioref">2023</a>)</span>,<span class="citation" data-cites="Measurement-in-quantum-mechanics_2024"><span>“Measurement in Quantum Mechanics”</span> (<a href="#ref-Measurement-in-quantum-mechanics_2024" role="doc-biblioref">2024</a>)</span>).</p>
</div>
</div>
</div>
<section id="notation" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="notation"><span class="header-section-number">1.1</span> Notation</h2>
<ul>
<li><p><span class="math inline">\(\H^n\)</span> is the set of <span class="math inline">\(n\times n\)</span> Hermitian matrices</p></li>
<li><p>Let <span class="math inline">\(X\in\H^n\)</span> such that <span class="math inline">\(X = V\Lambda V^*\)</span>, and <span class="math inline">\(f:\mathbb{R}\rightarrow\mathbb{R}\)</span> continuous, then we can define a spectral function <span class="math inline">\(F:\H^n\rightarrow \H^n\)</span> such that <span class="math inline">\(F(X) = \sum_{i=1}^n f(\lambda_i) v_i v_i^*\)</span>.</p></li>
<li><p><span class="math inline">\(S(X) = \tr(X\log X)\)</span> is the negative quantum entropy</p></li>
<li><p><span class="math inline">\(S(X|Y) = S(\rho^{AB})-S(\rho^B)\)</span> is the quantum conditional entropy</p></li>
<li><p><span class="math inline">\(S(X||Y) = \tr(X\log X - X\log Y)\)</span> is the quantum relative entropy</p></li>
<li><p><span class="math inline">\(s(x) = \sum_{i=1}^m x_i \log x_i\)</span> is the negative classical entropy</p></li>
<li><p><span class="math inline">\(s(x||y) = \sum_{i=1}^m x_i\log x_i - x_i \log y_i\)</span> is the classical relative entropy, also called the KL divergence</p></li>
</ul>
</section>
</section>
<section id="formulating-the-key-rate-calculation" class="level1 page-columns page-full" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Formulating the key rate calculation</h1>
<p>This section will go through how calculating the key rate can be written as a minimisation of relative entropy, which is the formulation presented by <span class="citation" data-cites="Winick_Lütkenhaus_Coles_2018">Winick, Lütkenhaus, and Coles (<a href="#ref-Winick_Lütkenhaus_Coles_2018" role="doc-biblioref">2018</a>)</span>.</p>
<p>The expression for the key rate that Winick et al.&nbsp;use comes from Theorem 2.6 of <span class="citation" data-cites="Devetak_Winter_2005">Devetak and Winter (<a href="#ref-Devetak_Winter_2005" role="doc-biblioref">2005</a>)</span>, with the assumption that Eve possesses a purification of the joint state of Alice and Bob (this is a worst case scenario, where Eve has the most amount of information about Alice and Bob’s systems). With this assumption about Eve’s state, the key rate can be written as</p>
<p><span class="math display">\[ K = p_{\text{pass}} \cdot \left( S(Z^R|E\tilde{A}\tilde{B})_\rho - \text{leak} \right),\]</span></p>
<p>where <span class="math inline">\(p_\text{pass}\)</span> is the probability of passing the sifting step in the protocol, <span class="math inline">\(Z^R\)</span> is a register storing information about the key, <span class="math inline">\(E\tilde{A}\tilde{B}\)</span> is the joint state of Eve, the purified state of Alice, and the purified state of Bob, <span class="math inline">\(\rho\)</span> is the density matrix representing the joint state of <span class="math inline">\(Z^R\)</span> and <span class="math inline">\(E\tilde{A}\tilde{B}\)</span>, and <span class="math inline">\(\text{leak}\)</span> is the number of bits of key map information that Eve learns through error correction. The specifics of purifications and the error correction process aren’t included as they are beyond the scope of this project, which is concerned with the optimisation problem itself.</p>
<p>Since only the conditional entropy term is dependent on <span class="math inline">\(\rho\)</span>, when we minimise over all <span class="math inline">\(\rho\)</span> to determine the worst case key rate, the <span class="math inline">\(\text{leak}\)</span> term does not need to be included in the objective. Winick et al.&nbsp;first use a result from <span class="citation" data-cites="Coles_2012">Coles (<a href="#ref-Coles_2012" role="doc-biblioref">2012</a>)</span> to transform the conditional entropy to a relative entropy in the form</p>
<p><span class="math display">\[p_{\text{pass}} S(V\rho^{(3)}V^*||\Z(V\rho^{(3)}V^*)),\]</span></p>
<p>where <span class="math inline">\(\rho^{(3)}\)</span> is result of the key distribution protocol acting on the joint state of Alice and Bob, which is explained in more detail below. The map <span class="math inline">\(\Z\)</span> is a pinching, pinchings have the property that <span class="math inline">\(||\Z(\rho)|| \leq ||\rho||\)</span> for every unitarily invariant norm <span class="citation" data-cites="Bhatia_1997">(<a href="#ref-Bhatia_1997" role="doc-biblioref">Bhatia 1997</a>)</span>.</p>
<p><span class="math inline">\(V\)</span> is an isometry which, when applied to <span class="math inline">\(\rho^{(3)}\)</span> stores the key information in a different register system <span class="math inline">\(R\)</span>, and <span class="math inline">\(\rho^{(3)}\)</span> is</p>
<p><span class="math display">\[\rho^{(3)} = \frac{\Pi \rho^{(2)} \Pi}{p_{\text{pass}}}.\]</span></p>
<p>Here, <span class="math inline">\(\Pi\)</span> is the projector defined to project to the subspace of announcements that Alice and Bob keep after sifting, <span class="math inline">\(\rho^{(2)}\)</span> is</p>
<p><span class="math display">\[\rho^{(2)} = \A(\rho_{AB}),\]</span></p>
<p>where <span class="math inline">\(\A\)</span> is a completely positive trace-preserving map representing the changes that happen to Alice and Bob’s joint state after passing through the quantum channel associated with Alice and Bob’s respective measurements and announcements of said measurements.</p>
<div id="tip-channels" class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;1: Quantum Channels
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>A quantum channel can be thought of as a passage through which quantum particles pass to get from Alice to Bob, and in this passage effects from the environment and Eve affect the particles (these are modelled by Kraus operators). But, a quantum channel can also describe what happens to a quantum particle in a quantum computer, or what happens to quantum particles when any sort of operation is applied. <em>Quantum channel</em> is the terminology used to describe when a quantum particle undergoes a change or series of changes, and those changes are modelled by Kraus operators.</p>
<p>One type of quantum channel, which will be used in <a href="#sec-bb84ex" class="quarto-xref">Section&nbsp;2.2</a>, is the depolarising channel. To talk about the depolarising channel, we need to introduce the Pauli gates/matrices. There are three Pauli matrices</p>
<p><span class="math display">\[X = \left[\begin{array}{cc} 0 &amp; 1 \\ 1 &amp; 0 \end{array} \right], \ Y = \left[\begin{array}{cc} 0 &amp; -i \\ i &amp; 0 \end{array} \right], \ Z = \left[\begin{array}{cc} 1 &amp; 0 \\ 0 &amp; -1 \end{array} \right].\]</span></p>
<p>Pauli <span class="math inline">\(X\)</span> is often called “bit flip”, because when acting on a qubit state it will flip the position of the <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span>, causing the state to go from <span class="math inline">\(\ket{0}\)</span> to <span class="math inline">\(\ket{1}\)</span>. Pauli <span class="math inline">\(Z\)</span> is often called “phase flip”, because it only changes <span class="math inline">\(\ket{1}\)</span> to <span class="math inline">\(-\ket{1}\)</span>, and doesn’t change <span class="math inline">\(\ket{0}\)</span>. The Pauli <span class="math inline">\(Y\)</span> doesn’t have another name.</p>
<p>Depolarising channels are used to model noise in quantum systems. They act linearly on the system state as</p>
<p><span class="math display">\[\mathcal{E}(\rho) = (1 - \frac{3}{4}p) \rho + \frac{p}{4}X \rho X^* + \frac{p}{4} Y \rho Y^* + \frac{p}{4} Z \rho Z^*, \]</span></p>
<p>where <span class="math inline">\(p\)</span> the probability that noise affects a change on the state <span class="citation" data-cites="Salfi-course_2023 Nielsen_Chuang_2012">(<a href="#ref-Salfi-course_2023" role="doc-biblioref">Salfi 2023</a>; <a href="#ref-Nielsen_Chuang_2012" role="doc-biblioref">Nielsen and Chuang 2012</a>)</span>.</p>
</div>
</div>
</div>
<p>The definitions of the operators <span class="math inline">\(\Z\)</span>, <span class="math inline">\(V\)</span>, <span class="math inline">\(\Pi\)</span>, and <span class="math inline">\(\A\)</span> are</p>
<ul>
<li><p><span class="math inline">\(\Z(\sigma) = \sum_j (\ket{j}\bra{j}_R \otimes \mathbf{1}) \sigma (\ket{j}\bra{j}_R \otimes \mathbf{1})\)</span>. The <span class="math inline">\(\ket{j}_R\)</span> denote standard basis elements in the register <span class="math inline">\(R\)</span>.</p></li>
<li><p><span class="math inline">\(V = \sum_{(a,\alpha_a,b)} \ket{g(a,\alpha_a,b)}_R \otimes \ket{a}\bra{a}_{\tilde{A}} \otimes \ket{\alpha_a}\bra{\alpha_a}_{\bar{A}} \otimes \ket{b}\bra{b}_{\tilde{B}}\)</span>. Here <span class="math inline">\(g(a,\alpha_a,b)\)</span> is a “key map", <span class="math inline">\((a,\alpha_a)\)</span> are the outcome of Alice’s measurements, <span class="math inline">\(b\)</span> is Bob’s announcement, and the output of <span class="math inline">\(g\)</span> is a value in <span class="math inline">\(\{0,1,...,N-1\}\)</span>, where <span class="math inline">\(N\)</span> is the number of key symbols. <span class="math inline">\(\tilde{A}\)</span> and <span class="math inline">\(\tilde{B}\)</span> are the registers that store Alice and Bob’s public announcements, <span class="math inline">\(a\)</span> and <span class="math inline">\(b\)</span>, respectively. <span class="math inline">\(\bar{A}\)</span> and <span class="math inline">\(\bar{B}\)</span> are registers that store Alice and Bob’s measurement outcomes for a given announcement, <span class="math inline">\(\alpha_a\)</span> and <span class="math inline">\(\beta_b\)</span>, respectively. When applied as a similarity transform on a state <span class="math inline">\(\rho\)</span>, it stores the key information of <span class="math inline">\(\rho\)</span> in the standard basis of <span class="math inline">\(R\)</span>.</p></li>
<li><p><span class="math inline">\(\Pi = \sum_{(a,b)\in A} \ket{a}\bra{a}_{\tilde{A}} \otimes \ket{b}\bra{b}_{\tilde{B}}\)</span>. <span class="math inline">\(A\)</span> is the set/register of announcements that are kept.</p></li>
<li><p><span class="math inline">\(\A(\rho) = \sum_{a,b} (K_a^A\otimes K_b^B)\rho (K_a^A\otimes K_b^B)^*\)</span>. <span class="math inline">\(K_a^A\)</span> and <span class="math inline">\(K_b^B\)</span> are Kraus operators, which are composed of operators representing different actions of a quantum channel on a quantum state.</p>
<ul>
<li><span class="math inline">\(K_a^A = \sum_{\alpha_a} \sqrt{P^A_{(a,\alpha_a)}} \otimes \ket{a}_{\tilde{A}} \otimes \ket{\alpha_a}_{\bar{A}}\)</span></li>
<li><span class="math inline">\(K_b^B = \sum_{\alpha_b} \sqrt{P^B_{(b,\beta_b)}} \otimes \ket{b}_{\tilde{B}} \otimes \ket{\alpha_b}_{\bar{B}}\)</span></li>
<li>The Kraus operators are built from POVMs, <span class="math inline">\(P^A_{(a,\alpha_a)}\)</span> and <span class="math inline">\(P^B_{(b,\beta_b)}\)</span>, in this case the POVMs represent the possible measurement outcomes for Alice and Bob.</li>
</ul></li>
</ul>
<p>Winick et al.&nbsp;then define an operator <span class="math inline">\(\G\)</span> that encompasses the changes to the state from <span class="math inline">\(V\)</span>, <span class="math inline">\(\Pi\)</span>, and <span class="math inline">\(\A\)</span></p>
<p><span class="math display">\[\G(\rho) =  V \Pi \A(\rho) \Pi V^*,\]</span></p>
<p>and use this to write the key rate calculation as</p>
<p><span id="eq-winickformulation"><span class="math display">\[\begin{aligned}
\begin{split}
    \min_\rho &amp; \ S(\G(\rho)||\Z(\G(\rho))) \\
    \st &amp; \ \Gamma(\rho) = \gamma, \\
    &amp; \ \rho \succeq 0,
\end{split}
\end{aligned} \tag{1}\]</span></span></p>
<p>where <span class="math inline">\(\rho\)</span> is used as a shorthand to denote <span class="math inline">\(\rho_{AB}\)</span>, the joint system of Alice and Bob, and <span class="math inline">\(\Gamma(\rho) = \{\tr(\Gamma_i \rho)\}_{i=1}^m\)</span>. Both the <span class="math inline">\(\Gamma_i\)</span> and <span class="math inline">\(\gamma\)</span> are determined from experimental data and help characterise the the density matrix <span class="math inline">\(\rho\)</span>, which is unknown.</p>
<p>This general form of the key rate calculation can be studied without needing the explicit definitions of <span class="math inline">\(\Z\)</span> and <span class="math inline">\(\G\)</span>, just by knowing that they are both linear, and <span class="math inline">\(\G\)</span> is a completely positive map and <span class="math inline">\(\Z\)</span> is a completely positive trace-preserving map. As the matrix logarithm is evaluated on the eigenvalues of the matrix, both <span class="math inline">\(\Z\)</span> and <span class="math inline">\(\G\)</span> must map to full rank matrices. Additionally, we know this is a convex optimisation problem, since it is known that relative entropy is jointly convex <span class="citation" data-cites="Effros_2009 Ebadian_Nikoufar_EshaghiGordji_2011">(<a href="#ref-Effros_2009" role="doc-biblioref">Effros 2009</a>; <a href="#ref-Ebadian_Nikoufar_EshaghiGordji_2011" role="doc-biblioref">Ebadian, Nikoufar, and Eshaghi Gordji 2011</a>)</span>.</p>
<section id="a-solution-approach-by-winick-et-al." class="level2 page-columns page-full" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="a-solution-approach-by-winick-et-al."><span class="header-section-number">2.1</span> A solution approach by Winick et al.</h2>
<p>Determining the key rate is an important step in analysing new key distribution protocols, and it is important that the key rate determined in the analysis is actually achievable. For that reason, Winick et al.&nbsp;chose to solve the problem via a dual method on the linearisation of the problem. By using a dual method, algorithmically the minimum (of the primal problem) is approached from below, assuring that the key rate is achievable.</p>
<p>Their approach is broken down into two steps: (1) find a close-to-optimal eavesdropping attack, which results in an upper bound on the key rate, (2) convert the upper bound into a lower bound.</p>
<p><strong>Step 1.</strong> The first component of Step 1 is to write <span class="math inline">\(\rho\)</span> in a subspace representation, to include the constraints <span class="math inline">\(\Gamma\)</span> inherently in the variable. They apply the Gram-Schmidt process to the <span class="math inline">\(\Gamma_i\)</span> and create <span class="math inline">\(\tilde{\Gamma}_i\)</span>, which is then extended to an orthonormal basis for <span class="math inline">\(\H^n\)</span> with matrices <span class="math inline">\(\Omega_j\)</span>, <span class="math inline">\(j=1,...,n-m\)</span>. The <span class="math inline">\(\gamma_i\)</span> are the expectation value of the <span class="math inline">\(\Gamma_i\)</span>, so the expectation value for the orthonormalised <span class="math inline">\(\tilde{\Gamma}_i\)</span> will be <span class="math inline">\(\tilde{\gamma}_i\)</span>. Now we can write the domain of the problem as</p>
<p><span class="math display">\[ E = \{ \sum_{i=1}^m \tilde{\gamma}_i \tilde{\Gamma}_i + \sum_{j=1}^{n-m} \omega_j \Omega_j \mid \omega\in\mathbb{R}^{n-m}\},\]</span></p>
<p>where the <span class="math inline">\(\tilde{\Gamma}_i\)</span> span the subspace defined by the constraints, and the <span class="math inline">\(\Omega_j\)</span> span the free subspace. Now, variable is reduced to a vector in <span class="math inline">\(\mathbb{R}^{n-m}\)</span>. With this framework, they adapt the Frank-Wolfe algorithm to minimise the unconstrained version of <a href="#eq-winickformulation" class="quarto-xref">Equation&nbsp;1</a>. The minimising argument is a density matrix which represents a system state after a possibly worst case eavesdropping attack. The algorithm Winick et al.&nbsp;use is</p>
<div class="wrapfigure page-columns page-full">
<div class="quarto-figure quarto-figure-center page-columns page-full">
<figure class="figure page-columns page-full">
<p><a href="winickalg1.PNG" class="lightbox" data-gallery="quarto-lightbox-gallery-2" data-glightbox="description: .lightbox-desc-2" title="Note: the algorithm is a screenshot from the Winick paper, I wasn’t able to find a pseudocode format I was satisfied with before the submission deadline."><img src="winickalg1.PNG" class="img-fluid figure-img" style="width:60.0%" alt="Note: the algorithm is a screenshot from the Winick paper, I wasn’t able to find a pseudocode format I was satisfied with before the submission deadline."></a></p>
<figcaption class="margin-caption">Note: the algorithm is a screenshot from the Winick paper, I wasn’t able to find a pseudocode format I was satisfied with before the submission deadline.</figcaption>
</figure>
</div>
</div>
<p>The notation is a little different, the differences are: their set <span class="math inline">\(S\)</span> is my set <span class="math inline">\(E\)</span>, <span class="math inline">\(f(\rho) = S(\G(\rho)||\Z(\G(\rho)))\)</span>. Line 2 is simply the semidefinite program</p>
<p><span class="math display">\[\begin{aligned}
\argmin_\omega &amp; \sum_{j=1}^{n-m} \omega_j \tr(\Omega_j\T \nabla f(\rho_i)) \\
\st &amp; \sum_{j=1}^{n-m} \omega_j \Omega_j + \rho_i \in \H^n,
\end{aligned}\]</span></p>
<p>since the only free variable is <span class="math inline">\(\omega\)</span>, which is then used to construct <span class="math inline">\(\Delta \rho = \sum_{j=1}^{n-m} \omega_j \Omega_j\)</span>.</p>
<p><strong>Step 2.</strong> Let <span class="math inline">\(\hat{\rho}\)</span> be the minimising argument from Step 1, Step 2 starts with linearising <span class="math inline">\(S(\G(\rho)||\Z(\G(\rho)))\)</span> about <span class="math inline">\(\hat{\rho}\)</span>. Due to numerical imprecision, <span class="math inline">\(\hat{\rho}\)</span> actually corresponds to a slight upper bound on the minimum, but we want the calculated key rate to actually be achievable. So, <span class="citation" data-cites="Winick_Lütkenhaus_Coles_2018">Winick, Lütkenhaus, and Coles (<a href="#ref-Winick_Lütkenhaus_Coles_2018" role="doc-biblioref">2018</a>)</span> determine the dual problem to the linearisation, and maximise that, thus resulting in a solution which is a lower bound to the primal problem.</p>
<p>An open-source solver based on this method is available under the name <a href="https://openqkdsecurity.wordpress.com/">Open QKD Security</a>.</p>
</section>
<section id="sec-bb84ex" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-bb84ex"><span class="header-section-number">2.2</span> Example: BB84 protocol</h2>
<p>This section will go through the first example in Appendix F of <span class="citation" data-cites="Winick_Lütkenhaus_Coles_2018">Winick, Lütkenhaus, and Coles (<a href="#ref-Winick_Lütkenhaus_Coles_2018" role="doc-biblioref">2018</a>)</span>. The example follows the BB84 protocol described in <a href="#nte-bb84" class="quarto-xref">Note&nbsp;1</a>, where Bob’s qubit detectors are not perfectly efficient. The experimentally determined constraints <span class="math inline">\(\Gamma\)</span> will be modelled by a depolarizing channel (see <a href="#tip-channels" class="quarto-xref">Tip&nbsp;1</a> for an explanation of a depolarising channel).</p>
<p>As described above, we know that Alice and Bob’s measurements of the qubits affect the state though the action of POVMs. Alice’s POVMs model whether or not Alice will measure a qubit in the <span class="math inline">\(z\)</span>-basis, and are written as</p>
<p><span class="math display">\[\begin{aligned}
&amp; P_1^A = p_z \ket{0}\bra{0}, \ P_2^A = p_z \ket{1}\bra{1}, \ P_3^A = (1-p_z) \ket{+}\bra{+}, \\
&amp; P_4^A = (1-p_z) \ket{-}\bra{-},
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(p_z\)</span> is the probability that Alice measures in the <span class="math inline">\(z\)</span>-basis, and <span class="math inline">\(\ket{\pm} = \frac{1}{\sqrt{2}} (\ket{0} \pm \ket{1})\)</span>.</p>
<div class="callout callout-style-default callout-tip no-icon callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<span class="math inline">\(z\)</span>-basis and the Bloch sphere
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>The state of a qubit can be visualised as being on the unit sphere, called the Bloch sphere in quantum mechanics.</p>
<div class="wrapfigure">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="blochsphere.png" class="lightbox" data-gallery="quarto-lightbox-gallery-3"><img src="blochsphere.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:60.0%"></a></p>
</figure>
</div>
</div>
<p>In the Bloch sphere diagram above, from <span class="citation" data-cites="ketterer-tel-01502539">Ketterer (<a href="#ref-ketterer-tel-01502539" role="doc-biblioref">2016</a>)</span>, the <span class="math inline">\(x\)</span>-, <span class="math inline">\(y\)</span>-, and <span class="math inline">\(z\)</span>-axes are labelled with their corresponding bases. The poles of the Bloch sphere correspond to <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span>, which are called the <span class="math inline">\(z\)</span>-basis.</p>
</div>
</div>
</div>
<p>Alice’s system is modelled in qubits, but Bob’s system will be modelled in qutrits (three bits), to account for the possibility that the qubit Alice sends just doesn’t arrive, this is called a “no-click” event. Bob’s POVMs are</p>
<p><span class="math display">\[\begin{aligned}
&amp; P_1^B = p_z \ket{0}\bra{0} \oplus 0, \ P_2^B = p_z \eta \ket{1}\bra{1} \oplus 0, \ P_3^B = (1-p_z) \ket{+}\bra{+} \oplus 0, \\
&amp; P_4^B \ket{-}\bra{-} \oplus 0, \ P_5^B = \one - \sum_{j=1}^4 P_j^B,
\end{aligned}\]</span></p>
<p>where the <span class="math inline">\(\oplus 0\)</span> indicates the addition of a third bit set to <span class="math inline">\(0\)</span>, and the factor <span class="math inline">\(\eta\)</span> represents detector inefficiency. The fifth POVM is the one representing a no-click event, in this case the third bit is set to <span class="math inline">\(1\)</span>.</p>
<p>The depolarising channel, which represents the environmental effects on the qubits, is modelled by the Kraus operators <span class="math inline">\(\sqrt{1-\frac{3}{4}p} I\)</span> (no change), <span class="math inline">\(\sqrt{\frac{p}{4}} X\)</span> (bit flip), <span class="math inline">\(\sqrt{\frac{p}{4}} Y\)</span> (bit flip with multiplication by <span class="math inline">\(i\)</span>), and <span class="math inline">\(\sqrt{\frac{p}{4}} Z\)</span> (phase flip), <span class="math inline">\(p\)</span> is the depolarising probability. How the channel acts on a state is defined as</p>
<p><span class="math display">\[ \mathcal{E}(\rho) = (1-\frac{3}{4}p) \rho + \frac{p}{4}X \rho X^* + \frac{p}{4} Y \rho Y^* + \frac{p}{4} Z \rho Z^*.\]</span></p>
<p>This depolarising channel is used to simulate the experimental data by applying it to a <a href="https://en.wikipedia.org/wiki/Quantum_entanglement#Entangled_states">maximally entangled state</a> <span class="math inline">\(\ket{\phi}\)</span> to generate <span class="math inline">\(\rho_\text{sim}\)</span>, which is then sampled by <span class="math inline">\(\Gamma_{jk} = P_j^A\otimes P_k^B\)</span> to generate the <span class="math inline">\(\gamma_i\)</span>.</p>
<p><span class="math display">\[\begin{aligned}
&amp; \rho_{\text{sim}} = (I \otimes \mathcal{E})(\ket{\phi}\bra{\phi}), \\
&amp; \gamma_{jk} = \tr((P_j^A\otimes P_k^B)\rho_{\text{sim}}),
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(I\)</span> (by my understanding) is the identity acting on the no-click qubit of Bob’s state (<span class="citation" data-cites="Renner_2008">Renner (<a href="#ref-Renner_2008" role="doc-biblioref">2008</a>)</span>), <span class="math inline">\(\ket{\phi}\)</span> is length <span class="math inline">\(6\)</span>, since a state vector of Alice and Bob’s joint state would be the tensor product of a state from Alice and a state from Bob, resulting in a length <span class="math inline">\(6\)</span> vector.</p>
<p>Calculating the Kraus operators is a straight forward application of the equation given before, so we move on to the definition of the projection operator that determines which measurements of Alice’s and Bob’s to keep. We want to make sure that only the measurements where Alice and Bob measure in the same basis are kept, that is, Alice measures <span class="math inline">\(\ket{0}\bra{0}\)</span> and Bob measures <span class="math inline">\(\ket{0}\bra{0}\)</span> OR Alice measures <span class="math inline">\(\ket{1}\bra{1}\)</span> and Bob measures <span class="math inline">\(\ket{1}\bra{1}\)</span>. The projector is written as</p>
<p><span class="math display">\[\Pi = \ket{0}\bra{0}_A \otimes \ket{0}\bra{0}_B + \ket{1}\bra{1}_A\otimes \ket{1}\bra{1}_B. \]</span></p>
<p>The last object to define is the isometry for the key map. It is defined such that Alice stores a 0 if she obtains outcome <span class="math inline">\(P_1^A\)</span> or <span class="math inline">\(P3^A\)</span>, and stores a 1 if she obtains outcome <span class="math inline">\(P_2^A\)</span> or <span class="math inline">\(P_4^A\)</span>, this is written as</p>
<p><span class="math display">\[ V = \ket{0}_R\otimes \ket{0}\bra{0}_A + \ket{1}_R\otimes \ket{1}\bra{1}_A,\]</span></p>
<p>where <span class="math inline">\(R\)</span> is the register of key values.</p>
<p>With this, all components are defined to create the maps <span class="math inline">\(\G\)</span>, <span class="math inline">\(\Z\)</span>, and <span class="math inline">\(\Gamma\)</span> for the optimisation problem in <a href="#eq-winickformulation" class="quarto-xref">Equation&nbsp;1</a>.</p>
<!-- This is a nice example to show how an actual key distribution protocol can be used to generate the operators needed for key rate analysis, but it doesn't give an accurate representation of the size of a real-world key distribution protocol. With an actual implementation of a key distribution protocol, Alice would be sending Bob many qubits, enough so that even after sifting and error correction, bits remain. That would mean that if Alice sends $n$ qubits, her state would be length $2^n$ [@Scarani_Bechmann-Pasquinucci_Cerf_Dušek_Lütkenhaus_Peev_2009], and Bob's state would be length $3^n$, and the size of the density matrix for their joint system would be $(2^n 3^n)\times (2^n 3^n)$. Now considering the number of constraints. Let $m_A$ be the number of Alice's POVMs, and $m_B$ the number of Bob's POVMs. Then, the formulation used by @Winick_Lütkenhaus_Coles_2018 has the number of constraints equal to $m_A m_B n$. For the given BB84 example with $n$ qubits, this would give $20n$ constraints. The fact that the number of constraints is significantly smaller than the size of the variable motivates a dual problem approach.  -->


<div class="hidden" aria-hidden="true">
<span class="glightbox-desc lightbox-desc-2">Note: the algorithm is a screenshot from the Winick paper, I wasn’t able to find a pseudocode format I was satisfied with before the submission deadline.</span>
</div>

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Bennett_Brassard_2014" class="csl-entry" role="listitem">
Bennett, Charles H., and Gilles Brassard. 2014. <span>“Quantum Cryptography: Public Key Distribution and Coin Tossing.”</span> <em>Theoretical Computer Science</em> 560: 7–11. <a href="https://doi.org/10.1016/j.tcs.2014.05.025">https://doi.org/10.1016/j.tcs.2014.05.025</a>.
</div>
<div id="ref-Bhatia_1997" class="csl-entry" role="listitem">
Bhatia, Rajendra. 1997. <em>Matrix Analysis</em>. New York: Springer.
</div>
<div id="ref-Broadbent_Schaffner_2016" class="csl-entry" role="listitem">
Broadbent, Anne, and Christian Schaffner. 2016. <span>“Quantum Cryptography Beyond Quantum Key Distribution.”</span> <em>Designs, Codes and Cryptography</em> 78 (1): 351–82. <a href="https://doi.org/10.1007/s10623-015-0157-4">https://doi.org/10.1007/s10623-015-0157-4</a>.
</div>
<div id="ref-Coles_2012" class="csl-entry" role="listitem">
Coles, Patrick J. 2012. <span>“Unification of Different Views of Decoherence and Discord.”</span> <em>Physical Review A</em> 85 (4): 042103. <a href="https://doi.org/10.1103/PhysRevA.85.042103">https://doi.org/10.1103/PhysRevA.85.042103</a>.
</div>
<div id="ref-Coles_Metodiev_Lütkenhaus_2016" class="csl-entry" role="listitem">
Coles, Patrick J., Eric M. Metodiev, and Norbert Lütkenhaus. 2016. <span>“Numerical Approach for Unstructured Quantum Key Distribution.”</span> <em>Nature Communications</em> 7 (1): 11712. <a href="https://doi.org/10.1038/ncomms11712">https://doi.org/10.1038/ncomms11712</a>.
</div>
<div id="ref-Devetak_Winter_2005" class="csl-entry" role="listitem">
Devetak, Igor, and Andreas Winter. 2005. <span>“Distillation of Secret Key and Entanglement from Quantum States.”</span> <em>Proceedings of the Royal Society A: Mathematical, Physical and Engineering Sciences</em> 461 (2053): 207–35. <a href="https://doi.org/10.1098/rspa.2004.1372">https://doi.org/10.1098/rspa.2004.1372</a>.
</div>
<div id="ref-Ebadian_Nikoufar_EshaghiGordji_2011" class="csl-entry" role="listitem">
Ebadian, Ali, Ismail Nikoufar, and Madjid Eshaghi Gordji. 2011. <span>“Perspectives of Matrix Convex Functions.”</span> <em>Proceedings of the National Academy of Sciences</em> 108 (18): 7313–14. <a href="https://doi.org/10.1073/pnas.1102518108">https://doi.org/10.1073/pnas.1102518108</a>.
</div>
<div id="ref-Effros_2009" class="csl-entry" role="listitem">
Effros, Edward G. 2009. <span>“A Matrix Convexity Approach to Some Celebrated Quantum Inequalities.”</span> <em>Proceedings of the National Academy of Sciences</em> 106 (4): 1006–8. <a href="https://doi.org/10.1073/pnas.0807965106">https://doi.org/10.1073/pnas.0807965106</a>.
</div>
<div id="ref-ketterer-tel-01502539" class="csl-entry" role="listitem">
Ketterer, Andreas. 2016. <span>“<span class="nocase">Modular variables in quantum information</span>.”</span> Theses, <span>Universit<span>é</span> Paris 7, Sorbonne Paris Cit<span>é</span></span>. <a href="https://theses.hal.science/tel-01502539">https://theses.hal.science/tel-01502539</a>.
</div>
<div id="ref-Measurement-in-quantum-mechanics_2024" class="csl-entry" role="listitem">
<span>“Measurement in Quantum Mechanics.”</span> 2024. <em>Wikipedia</em>. <a href="https://en.wikipedia.org/w/index.php?title=Measurement_in_quantum_mechanics&amp;oldid=1204214011">https://en.wikipedia.org/w/index.php?title=Measurement_in_quantum_mechanics&amp;oldid=1204214011</a>.
</div>
<div id="ref-Nielsen_Chuang_2012" class="csl-entry" role="listitem">
Nielsen, Michael A., and Isaac L. Chuang. 2012. <em>Quantum Computation and Quantum Information: 10th Anniversary Edition</em>. 1st ed. Cambridge University Press. <a href="https://doi.org/10.1017/CBO9780511976667">https://doi.org/10.1017/CBO9780511976667</a>.
</div>
<div id="ref-Quantum-entanglement_2024" class="csl-entry" role="listitem">
<span>“Quantum Entanglement.”</span> 2024. <em>Wikipedia</em>. <a href="https://en.wikipedia.org/w/index.php?title=Quantum_entanglement&amp;oldid=1196168679">https://en.wikipedia.org/w/index.php?title=Quantum_entanglement&amp;oldid=1196168679</a>.
</div>
<div id="ref-Qubit_2024" class="csl-entry" role="listitem">
<span>“Qubit.”</span> 2024. <em>Wikipedia</em>. <a href="https://en.wikipedia.org/w/index.php?title=Qubit&amp;oldid=1208400062">https://en.wikipedia.org/w/index.php?title=Qubit&amp;oldid=1208400062</a>.
</div>
<div id="ref-Renner_2008" class="csl-entry" role="listitem">
Renner, Renato. 2008. <span>“SECURITY OF QUANTUM KEY DISTRIBUTION.”</span> <em>International Journal of Quantum Information</em> 06 (01): 1–127. <a href="https://doi.org/10.1142/S0219749908003256">https://doi.org/10.1142/S0219749908003256</a>.
</div>
<div id="ref-Salfi-course_2023" class="csl-entry" role="listitem">
Salfi, Joe. 2023. <span>“Intro to Quantum Information and Computing.”</span> Course, September.
</div>
<div id="ref-Winick_Lütkenhaus_Coles_2018" class="csl-entry" role="listitem">
Winick, Adam, Norbert Lütkenhaus, and Patrick J. Coles. 2018. <span>“Reliable Numerical Key Rates for Quantum Key Distribution.”</span> <em>Quantum</em> 2 (July): 77. <a href="https://doi.org/10.22331/q-2018-07-26-77">https://doi.org/10.22331/q-2018-07-26-77</a>.
</div>
</div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<script src="https://giscus.app/client.js" data-repo="e-vic/e-vic.github.io" data-repo-id="R_kgDOMOCiIQ" data-category="General" data-category-id="DIC_kwDOMOCiIc4CgYjG" data-mapping="title" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="light" data-lang="en" crossorigin="anonymous" async="">
</script>
<input type="hidden" id="giscus-base-theme" value="light">
<input type="hidden" id="giscus-alt-theme" value="dark">
</div> <!-- /content -->
<script>var lightboxQuarto = GLightbox({"loop":false,"selector":".lightbox","descPosition":"bottom","openEffect":"zoom","closeEffect":"zoom"});
window.onload = () => {
  lightboxQuarto.on('slide_before_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    const href = trigger.getAttribute('href');
    if (href !== null) {
      const imgEl = window.document.querySelector(`a[href="${href}"] img`);
      if (imgEl !== null) {
        const srcAttr = imgEl.getAttribute("src");
        if (srcAttr && srcAttr.startsWith("data:")) {
          slideConfig.href = srcAttr;
        }
      }
    } 
  });

  lightboxQuarto.on('slide_after_load', (data) => {
    const { slideIndex, slideNode, slideConfig, player, trigger } = data;
    if (window.Quarto?.typesetMath) {
      window.Quarto.typesetMath(slideNode);
    }
  });

};
          </script>




</body></html>